; encoding - Windows 1251

.model small ; TBD
.stack 100h ; размер стека программы - 256 байт, т.к. стек практически не используется можно уменьшить на порядок
.data ; сегмент данных
; приветственное сообщение, завершается символами перевода строки,
; здесь и далее, символ $ - маркер конца строки в соответствии со спецификацией 
; функцией 9h, DOS прерывания int 21h (см. процедуру print)
m_greeting	db 'Программа перевода из десятичной системы в римскую. Для выхода из программы нажмите ноль', 0dh, 0ah, '$'
; приглашение к вводу числа
m_prompt	db 'Введите целое число в десятичной системе', 0dh, 0ah, '$'
; сообщение о некорректном вводе
m_error		db 'Введено некорректное значение', 0dh, 0ah, '$'
; сообщение о выводе результата
m_result	db 'Результат в римской системе: ', '$'
; сообщение о выходе из программы
m_quit		db 'Вы вышли из программы', 0dh, 0ah, '$'
; символы перевода строки для самостоятельного использования
m_crlf		db 0dh, 0ah, '$'

; буфер для входных данных, структурирован в соответствии со спецификацией функции 0ah 
; DOS прерывания 21h
ibuffer label ; метка для получения адреса буфера
; максимальное количество символов для ввода в буфер
ibuffer_limit	db 4
; фактическая длина буфера после ввода
ibuffer_length	db 0
; непосредственно результат ввода
ibuffer_data 	db 5 dup (?)
; буфер для строки-результата преобразования, 20 символов должно хватить на вывод чисел в пределах 1000
obuffer_data	db 20 dup (?) ; (?) - буфер не инициализируется, содержимое все-равно будет перезаписано

 .code ; сегмент кода

print proc ; процедура вывода строки на консоль
	; входные параметры: dx - адрес строки для вывода
	; выходные параметры - ax = 0900h
	mov ax, 0900h
	int 21h ; DOS прерывание 21h, функция 9h

	ret ; возврат из процедуры
print endp ; конец процедуры


x_digit proc ; преобразование основания числа в односимвольное римское обозначение с записью в буфер
	; входные параметры
		; dx - число в двоичной системе
		; bx - основание
		; cx - обозначение основания в римской системе, значимая часть только cl
		; es:di - указатель на буфер с результатом преобразования
	; выходные параметры
		; dx - остаток от деления числа на основание
		; es:di - указатель на хвост буфера для результата
	mov ax, dx ; формирование делимого dx:ax = 0:dx
	xor dx, dx ; dx = 0 	
	div bx ; целочисленное деление 4 байтного числа dx:ax на bx
	; ax - результат деления, dx - остаток от деления

	xchg ax, cx ; cx - счетчик повторений обозначения в результирующем буфере
	; ax - обозначение для записи в буфер
	rep stosb ; записать cx байт по адресу es:di значением из al, увеличить di на cx

	ret ; возврат из процедуры
x_digit endp ; конец процедуры x_digit


x_digit2 proc ; преобразование основания числа в двухсимвольное римское обозначение с записью в буфер
	; входные параметры
		; dx - число в двоичной системе
		; bx - основание
		; cx - обозначение основания в римской системе, значимые оба байта
		; es:di - указатель на буфер с результатом преобразования
	; выходные параметры
		; dx - остаток от деления числа на основание
		; es:di - указатель на хвост буфера для результата
	mov ax, dx ; формирование делимого dx:ax = 0:dx
	xor dx, dx; dx = 0
	div bx ; целочисленное деление 4 байтного числа dx:ax на bx
	; ax - результат деления, dx - остаток от деления

	xchg ax, cx ; cx - счетчик повторий обозначения в результирующем буфере
	; по факту никакое из двухсимвольных обозначений не может встречаться более 1 раза, но
	; для единообразия с x_digit используется подход с rep stos, как более линейный
	rep stosw ; записать cx слов (2 байта) по адресу es:di значением из ax, увеличить di на cx*2

	ret ; возврат из процедуры
x_digit2 endp ; конец процедуры x_digit2


start:  ; начало самой программы
	mov ax, @data ; загружается адрес сегмента данных, напрямую писать в ds и es нельзя
	mov ds, ax ; инициализируется ds и es
	mov es, ax

	; вывод приветствия
	mov dx, offset m_greeting
	call print

main: ; метка главного цикла программы (ввод->преобразование->вывод)
	; приглашение для ввода числа
	mov dx, offset m_prompt
	call print

	; ввод строки пользователем в ibuffer
	mov ax, 0a00h ; функция 0ah 
	mov dx, offset ibuffer 
	int 21h ; DOS прерывание 21h

	; перевод строки, чтобы не последующий вывод не затер введенную пользователем строку
	mov dx, offset m_crlf
	call print

	; если было введено более чем 01 символов или первый символ не '0' (30h)
	cmp word ptr [ibuffer_length], 3001h ; (важно помнить о порядке байт в слове, младший байт идет первым)
	jne process ; то работа продолжается
	jmp exit ; иначе выход из программы

process:
	xor cx, cx ; cx = 0, аккумлятор для 
	mov bx, 1 ; bx - хранит текущую базу десятичноо числа, начинаем обработку с конца, поэтому bx = 1

	xor ah, ah ; ah = 0
	mov al, [ibuffer_length]
	mov si, ax ; si = индекс текущего символа строки с десятичным числом, начинаем с последнего
	; (в si нельзя писать напрямую, только через другой регистр)
	mov di, 0ah ; di хранит основание позиции десятичной системы - т.е. 10, исплользуется для умножения

dec2bin: ; метка для основного цикла преобразования строки с десятичным числом в двоичной число
	; преобазование совмещено с проверкой что исходная строка состоит только из символов от '0' до '9'

	xor ah, ah 
	mov	al, [ibuffer_data + si - 1] ; ax = текущий символ десятичного числа
	
	sub al, '0' ; приводим символ к бинарному числу посредством вычитания '0'
	jb error ; если результат оказался меньше нуля, значит был некорректный ввод
	; условные переходы нельзя делать на расстояние более 127 байт, 
	; поэтому приходится держать обработчик ошибок поблизости, отсюда немного странная структура логики кода 

	cmp al, 9 ; если бинарное число больше 9, то был некорректные ввод
	jg error ; обрабатываем ошибку

	mul bx ; умножение двоичного числа в ax на текущее основание в bx
	add cx, ax ; добавляем результат к аккумулятору в cx
	
	mov ax, bx ; увеличиваем базу в 10 раз для обработки следующего символа в строке
	mul di ; умножаем ax на di
	mov bx, ax ; bx = новая база

	dec si ; si уменьшается на 1
	jnz dec2bin  ; если не добрались до последний введенного символа, продолжаем преобразование
	jmp bin2roman ; иначе, приступаем к конвертации в римскую систему


error: ; обработчик ошибок ввода десятичного числа
	mov	dx, offset m_error ; вывод сообщения об ошибке
	call print

	jmp main ; продолжаем работу программы с начала цикла

bin2roman:
	; настройка di, указывает на начало выходного буфера
	lea di, [obuffer_data]

M: ; здесь и далее метки оснований римской системы нужны только для читаемости кода
	mov dx, cx ; dx = исходное число в бинарном виде, осталось в cx со времен dec2bin
	mov bx, 1000 ; основание 1000
	mov cx, 'M' ; обозначается как 'M'
	call x_digit

CM:
	; вычисление основания 900, обозначается как 'CM', важно - младший байт слова идет первым
	mov bx, 900
	mov cx, 'MC'
	call x_digit2

D:
	; вычисление основания 500, обозначается как 'D'
	mov bx, 500
	mov cx, 'D'
	call x_digit

CD:
	; вычисление основания 400, обозначается как 'CD', важно - младший байт слова идет первым
	mov bx, 400
	mov cx, 'DC'
	call x_digit2

C:
	; вычисление основания 100, обозначается как 'C'
	mov bx, 100
	mov cx, 'C'
	call x_digit 

XC:
	; вычисление основания 90, обозначается как 'XC', важно - младший байт слова идет первым
	mov bx, 90
	mov cx, 'CX'
	call x_digit2

L:
	; вычисление основания 50, обозначается как 'L'
	mov bx, 50
	mov cx, 'L'
	call x_digit

XL:
	; вычисление основания 40, обозначается как 'XL', важно - младший байт слова идет первым
	mov bx, 40
	mov cx, 'LX'
	call x_digit2

X:
	; вычисление основания 10, обозначается как 'X'
	mov bx, 10
	mov cx, 'X'
	call x_digit

IX:
	; вычисление основания 9, обозначается как 'XI', важно - младший байт слова идет первым
	mov bx, 9
	mov cx, 'XI'
	call x_digit2

V:
	; вычисление основания 5, обозначается как 'V'
	mov bx, 5
	mov cx, 'V'
	call x_digit

IV:
	; вычисление основания 4, обозначается как 'IV', важно - младший байт слова идет первым
	mov bx, 4
	mov cx, 'VI'
	call x_digit2

I:
	; вычисление основания 1, обозначается как 'I'
	mov bx, 1
	mov cx, 'I'
	call x_digit

	; добавляем к результату терминирующий символ '$', для использования в процедуре print
	mov al, '$'
	; по адресу es:di записать содержимое al, после последнего вызова x_digit di указывает на конец выходного буфера
	stosb 

	; вывод на консоль сообщения о результате
	mov dx, offset m_result
	call print

	; перевод каретки консоли на новую строку
	mov dx, offset m_crlf
	call print

	; вывод на консоль результата преобразования
	mov dx, offset obuffer_data
	call print

	; перевод каретки консоли на новую строку
	mov dx, offset m_crlf
	call print	

	jmp main ; переход к началу главного цикла

exit: ; метка логики выхода из программы
	; вывод прощального сообщения
	mov dx, offset m_quit
	call print

	mov	ax, 04c00h ; функция 4ch DOS прерывания 21h - выход из программы 
	int	21h
	
    end start ; конец программы